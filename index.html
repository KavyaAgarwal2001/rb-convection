<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Boussinesq Convection Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 10px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            text-align: center;
            color: #b8d4f3;
            margin-bottom: 30px;
            font-size: 1.2em;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            color: #e8f4f8;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            margin-bottom: 5px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .value-display {
            color: #4CAF50;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: linear-gradient(45deg, #666, #555);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .canvas-wrapper {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }
        
        .canvas-title {
            color: #e8f4f8;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        canvas {
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 100%;
            height: auto;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-box {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #b8d4f3;
            font-size: 0.9em;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-panel h3 {
            color: #4CAF50;
            margin-bottom: 15px;
        }
        
        .info-panel p {
            color: #b8d4f3;
            line-height: 1.6;
            margin-bottom: 10px;
        }
        
        @media (max-width: 768px) {
            .canvas-container {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>2D Boussinesq Convection Simulation</h1>
        <div class="subtitle">Interactive Rayleigh-Bénard Convection Solver</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="rayleigh">Rayleigh Number (Ra)</label>
                <input type="range" id="rayleigh" min="1000" max="50000" value="5000" step="500">
                <div class="value-display" id="rayleigh-value">5000</div>
            </div>
            
            <div class="control-group">
                <label for="resolution">Grid Resolution</label>
                <input type="range" id="resolution" min="32" max="128" value="64" step="8">
                <div class="value-display" id="resolution-value">64×64</div>
            </div>
            
            <div class="control-group">
                <label for="timestep">Time Step (×10⁻⁶)</label>
                <input type="range" id="timestep" min="1" max="50" value="10" step="1">
                <div class="value-display" id="timestep-value">1.0e-5</div>
            </div>
            
            <div class="control-group">
                <label for="speed">Animation Speed</label>
                <input type="range" id="speed" min="1" max="10" value="5" step="1">
                <div class="value-display" id="speed-value">5</div>
            </div>
        </div>
        
        <div class="button-group">
            <button id="startBtn">Start Simulation</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
        </div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="canvas-title">Temperature Field</div>
                <canvas id="tempCanvas" width="400" height="200"></canvas>
            </div>
            
            <div class="canvas-wrapper">
                <div class="canvas-title">Streamfunction & Velocity</div>
                <canvas id="flowCanvas" width="400" height="200"></canvas>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="step-count">0</div>
                <div class="stat-label">Time Steps</div>
            </div>
            
            <div class="stat-box">
                <div class="stat-value" id="nusselt-number">1.00</div>
                <div class="stat-label">Nusselt Number</div>
            </div> 
           
            <div class="stat-box">
                <div class="stat-value" id="max-velocity">0.00</div>
                <div class="stat-label">Max Velocity</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="sim-time">0.000</div>
                <div class="stat-label">Simulation Time</div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>About Rayleigh-Bénard Convection</h3>
            <p><strong>Temperature Field:</strong> Shows hot fluid (red) rising from the bottom and cold fluid (blue) sinking from the top, forming convection cells.</p>
            <p><strong>Streamfunction & Velocity:</strong> Displays the circulation patterns with velocity vectors showing fluid motion.</p>
            <p><strong>Nusselt Number:</strong> Measures heat transfer efficiency. Nu = 1 means pure conduction, Nu > 1 indicates convective enhancement.</p>
            <p><strong>Physics:</strong> This simulation solves the Boussinesq equations using streamfunction-vorticity formulation, the same physics governing weather patterns, ocean currents, and planetary mantle convection!</p>
        </div>
    </div>

    <script>
        class BoussinesqSolver {
            constructor(Ra = 5000, nx = 64, nz = 64, Lx = 2.0, Lz = 1.0, dt = 1e-5) {
                this.Ra = Ra;
                this.nx = nx;
                this.nz = nz;
                this.Lx = Lx;
                this.Lz = Lz;
                this.dx = Lx / (nx - 1);
                this.dz = Lz / (nz - 1);
                this.dt = dt;
                
                this.x = Array.from({length: nx}, (_, i) => i * this.dx);
                this.z = Array.from({length: nz}, (_, i) => i * this.dz);
                
                this.T = Array(nz).fill().map(() => Array(nx).fill(0));
                this.psi = Array(nz).fill().map(() => Array(nx).fill(0));
                this.omega = Array(nz).fill().map(() => Array(nx).fill(0));
                
                this.initializeTemperature();
            }
            
            initializeTemperature() {
                for (let i = 0; i < this.nz; i++) {
                    for (let j = 0; j < this.nx; j++) {
                        // Linear conductive profile
                        this.T[i][j] = 1 - (i * this.dz) / this.Lz;
                        
                        // Add perturbation
                        const perturbation = 0.01 * (Math.random() - 0.5);
                        const sinFactor = Math.sin(Math.PI * (i * this.dz) / this.Lz);
                        this.T[i][j] += perturbation * sinFactor;
                    }
                }
                this.applyTemperatureBc();
            }
            
            applyTemperatureBc() {
                for (let j = 0; j < this.nx; j++) {
                    this.T[0][j] = 1.0;  // Hot bottom
                    this.T[this.nz-1][j] = 0.0;  // Cold top
                }
                for (let i = 0; i < this.nz; i++) {
                    this.T[i][0] = this.T[i][1];  // Left boundary
                    this.T[i][this.nx-1] = this.T[i][this.nx-2];  // Right boundary
                }
            }
            
            applyStreamfunctionBc() {
                for (let j = 0; j < this.nx; j++) {
                    this.psi[0][j] = 0;
                    this.psi[this.nz-1][j] = 0;
                }
                for (let i = 0; i < this.nz; i++) {
                    this.psi[i][0] = 0;
                    this.psi[i][this.nx-1] = 0;
                }
            }
            
            applyVorticityBc() {
                for (let j = 0; j < this.nx; j++) {
                    this.omega[0][j] = 0;
                    this.omega[this.nz-1][j] = 0;
                }
                for (let i = 0; i < this.nz; i++) {
                    this.omega[i][0] = 0;
                    this.omega[i][this.nx-1] = 0;
                }
            }
            
            solvePoisson(field, rhs, maxIter = 50) {
                const result = field.map(row => [...row]);
                const dx2 = this.dx * this.dx;
                const dz2 = this.dz * this.dz;
                const factor = 0.5 / (1/dx2 + 1/dz2);
                
                for (let iter = 0; iter < maxIter; iter++) {
                    for (let i = 1; i < this.nz - 1; i++) {
                        for (let j = 1; j < this.nx - 1; j++) {
                            result[i][j] = factor * (
                                (result[i+1][j] + result[i-1][j]) / dz2 +
                                (result[i][j+1] + result[i][j-1]) / dx2 -
                                rhs[i][j]
                            );
                        }
                    }
                }
                return result;
            }
            
            computeVelocities() {
                const u = Array(this.nz).fill().map(() => Array(this.nx).fill(0));
                const w = Array(this.nz).fill().map(() => Array(this.nx).fill(0));
                
                for (let i = 1; i < this.nz - 1; i++) {
                    for (let j = 0; j < this.nx; j++) {
                        u[i][j] = -(this.psi[i+1][j] - this.psi[i-1][j]) / (2 * this.dz);
                    }
                }
                
                for (let i = 0; i < this.nz; i++) {
                    for (let j = 1; j < this.nx - 1; j++) {
                        w[i][j] = (this.psi[i][j+1] - this.psi[i][j-1]) / (2 * this.dx);
                    }
                }
                
                return { u, w };
            }
            
            computeTemperatureGradient() {
                const dT_dx = Array(this.nz).fill().map(() => Array(this.nx).fill(0));
                const dT_dz = Array(this.nz).fill().map(() => Array(this.nx).fill(0));
                
                for (let i = 0; i < this.nz; i++) {
                    for (let j = 1; j < this.nx - 1; j++) {
                        dT_dx[i][j] = (this.T[i][j+1] - this.T[i][j-1]) / (2 * this.dx);
                    }
                }
                
                for (let i = 1; i < this.nz - 1; i++) {
                    for (let j = 0; j < this.nx; j++) {
                        dT_dz[i][j] = (this.T[i+1][j] - this.T[i-1][j]) / (2 * this.dz);
                    }
                }
                
                return { dT_dx, dT_dz };
            }
            
            timeStep() {
                // 1. Solve for streamfunction: ∇²ψ = -ω
                this.psi = this.solvePoisson(this.psi, this.omega.map(row => row.map(x => -x)));
                this.applyStreamfunctionBc();
                
                // 2. Solve for vorticity: ∇²ω = Ra * ∂T/∂x
                const { dT_dx } = this.computeTemperatureGradient();
                const rhs_omega = dT_dx.map(row => row.map(x => this.Ra * x));
                this.omega = this.solvePoisson(this.omega, rhs_omega);
                this.applyVorticityBc();
                
                // 3. Update temperature
                const { u, w } = this.computeVelocities();
                const { dT_dx: dTdx, dT_dz: dTdz } = this.computeTemperatureGradient();
                
                const T_new = this.T.map(row => [...row]);
                
                for (let i = 1; i < this.nz - 1; i++) {
                    for (let j = 1; j < this.nx - 1; j++) {
                        const advection = u[i][j] * dTdx[i][j] + w[i][j] * dTdz[i][j];
                        const diffusion = (this.T[i+1][j] - 2*this.T[i][j] + this.T[i-1][j]) / (this.dz*this.dz) +
                                        (this.T[i][j+1] - 2*this.T[i][j] + this.T[i][j-1]) / (this.dx*this.dx);
                        
                        T_new[i][j] = this.T[i][j] + this.dt * (-advection + diffusion);
                    }
                }
                
                this.T = T_new;
                this.applyTemperatureBc();
                
                return { u, w };
            }
            
            computeNusseltNumber() {
                let dT_dz_top = 0;
                for (let j = 1; j < this.nx - 1; j++) {
                    dT_dz_top += (this.T[this.nz-1][j] - this.T[this.nz-2][j]) / this.dz;
                }
                return -dT_dz_top / (this.nx - 2);
            }
            
            getMaxVelocity() {
                const { u, w } = this.computeVelocities();
                let maxVel = 0;
                for (let i = 0; i < this.nz; i++) {
                    for (let j = 0; j < this.nx; j++) {
                        const vel = Math.sqrt(u[i][j]*u[i][j] + w[i][j]*w[i][j]);
                        maxVel = Math.max(maxVel, vel);
                    }
                }
                return maxVel;
            }
        }
        
        class ConvectionVisualizer {
            constructor() {
                this.tempCanvas = document.getElementById('tempCanvas');
                this.flowCanvas = document.getElementById('flowCanvas');
                this.tempCtx = this.tempCanvas.getContext('2d');
                this.flowCtx = this.flowCanvas.getContext('2d');
                
                this.solver = null;
                this.isRunning = false;
                this.stepCount = 0;
                this.simTime = 0;
                this.animationId = null;
                
                this.setupControls();
                this.initializeSolver();
            }
            
            setupControls() {
                const rayleighSlider = document.getElementById('rayleigh');
                const resolutionSlider = document.getElementById('resolution');
                const timestepSlider = document.getElementById('timestep');
                const speedSlider = document.getElementById('speed');
                
                rayleighSlider.addEventListener('input', (e) => {
                    document.getElementById('rayleigh-value').textContent = e.target.value;
                    if (!this.isRunning) this.initializeSolver();
                });
                
                resolutionSlider.addEventListener('input', (e) => {
                    const res = e.target.value;
                    document.getElementById('resolution-value').textContent = `${res}×${res}`;
                    if (!this.isRunning) this.initializeSolver();
                });
                
                timestepSlider.addEventListener('input', (e) => {
                    const dt = e.target.value / 1000000;
                    document.getElementById('timestep-value').textContent = dt.toExponential(1);
                    if (!this.isRunning) this.initializeSolver();
                });
                
                speedSlider.addEventListener('input', (e) => {
                    document.getElementById('speed-value').textContent = e.target.value;
                });
                
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            }
            
            initializeSolver() {
                const Ra = parseInt(document.getElementById('rayleigh').value);
                const res = parseInt(document.getElementById('resolution').value);
                const dt = parseInt(document.getElementById('timestep').value) / 1000000;
                
                this.solver = new BoussinesqSolver(Ra, res, res, 2.0, 1.0, dt);
                this.stepCount = 0;
                this.simTime = 0;
                this.updateDisplay();
            }
            
            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('pauseBtn').disabled = false;
                    this.animate();
                }
            }
            
            pause() {
                if (this.isRunning) {
                    this.isRunning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = true;
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                    }
                }
            }
            
            reset() {
                this.pause();
                this.initializeSolver();
            }
            
            animate() {
                if (!this.isRunning) return;
                
                const speed = parseInt(document.getElementById('speed').value);
                
                for (let i = 0; i < speed; i++) {
                    this.solver.timeStep();
                    this.stepCount++;
                    this.simTime += this.solver.dt;
                }
                
                this.updateDisplay();
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            updateDisplay() {
                this.drawTemperatureField();
                this.drawFlowField();
                this.updateStats();
            }
            
            drawTemperatureField() {
                const ctx = this.tempCtx;
                const canvas = this.tempCanvas;
                const { T } = this.solver;
                const nx = this.solver.nx;
                const nz = this.solver.nz;
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < canvas.height; i++) {
                    for (let j = 0; j < canvas.width; j++) {
                        const zi = Math.floor((i / canvas.height) * nz);
                        const xi = Math.floor((j / canvas.width) * nx);
                        const temp = T[zi][xi];
                        
                        // Color mapping: blue (cold) to red (hot)
                        const r = Math.floor(255 * Math.max(0, Math.min(1, temp * 2)));
                        const g = Math.floor(255 * Math.max(0, Math.min(1, 1 - Math.abs(temp - 0.5) * 2)));
                        const b = Math.floor(255 * Math.max(0, Math.min(1, (1 - temp) * 2)));
                        
                        const idx = (i * canvas.width + j) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            drawFlowField() {
                const ctx = this.flowCtx;
                const canvas = this.flowCanvas;
                const { u, w } = this.solver.computeVelocities();
                const nx = this.solver.nx;
                const nz = this.solver.nz;
                
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw streamlines
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 1;
                
                const skip = Math.max(1, Math.floor(nx / 16));
                const scale = 20;
                
                for (let i = skip; i < nz - skip; i += skip) {
                    for (let j = skip; j < nx - skip; j += skip) {
                        const x = (j / nx) * canvas.width;
                        const y = (i / nz) * canvas.height;
                        
                        const ux = u[i][j] * scale;
                        const wy = w[i][j] * scale;
                        
                        if (Math.abs(ux) > 0.1 || Math.abs(wy) > 0.1) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + ux, y + wy);
                            ctx.stroke();
                            
                            // Arrow head
                            const angle = Math.atan2(wy, ux);
                            const headlen = 3;
                            ctx.beginPath();
                            ctx.moveTo(x + ux, y + wy);
                            ctx.lineTo(x + ux - headlen * Math.cos(angle - Math.PI/6), 
                                     y + wy - headlen * Math.sin(angle - Math.PI/6));
                            ctx.moveTo(x + ux, y + wy);
                            ctx.lineTo(x + ux - headlen * Math.cos(angle + Math.PI/6), 
                                     y + wy - headlen * Math.sin(angle + Math.PI/6));
                            ctx.stroke();
                        }
                    }
                }
            }
            
            updateStats() {
                document.getElementById('step-count').textContent = this.stepCount.toLocaleString();
                document.getElementById('nusselt-number').textContent = this.solver.computeNusseltNumber().toFixed(2);
                document.getElementById('max-velocity').textContent = this.solver.getMaxVelocity().toFixed(3);
                document.getElementById('sim-time').textContent = this.simTime.toFixed(6);
            }
        }
        
        // Initialize the visualization
        const visualizer = new ConvectionVisualizer();
    </script>
</body>
</html>